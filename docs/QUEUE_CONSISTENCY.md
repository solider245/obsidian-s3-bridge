# 队列一致性与单实例防护建议

目标：确保上传队列在“并发、启停、异常”条件下仍保持强一致与可恢复，避免重复消费、丢失项与状态错乱。

适用范围：粘贴-入队-占位-上传-替换-清理 全链路；手动处理与最小 Scheduler 并存。

一、队列数据模型与持久化

- 持久化位置：plugin.saveData().uploadQueue（数组，队首为下一条）
- 字段：id、filename、mime、path（vault 相对路径）、createdAt、size、base64Length
- 关键要求：
  1. path 始终保存 vault 相对路径（非 app://），避免适配器读取失败
  2. 入队 id 唯一（基于时间戳 + 随机数），可复用为对象键的后备
  3. 占位 markdown 中携带 uploadId，用于后续定位与替换

二、处理流程与一致性策略

1. 读取顺序

- 优先从 optimistic 内存缓存取 base64
- 次选从 vault 文件读取（对 path 做 ? 查询串剥离）
- 均失败则判定为失败：替换失败占位，队列项保留

2. 幂等与出队

- performUpload 成功后才执行：
  - 替换编辑器占位为最终 URL
  - 尝试删除临时文件（尽力而为，不影响成功路径）
  - 清理 optimistic 缓存
  - 出队（保存队列）
- 失败不出队，便于重试

3. 并发与单实例

- 处理端（命令 & 调度器）统一复用 processNext()，内部串行化
- 调度器每 tick 仅处理 1 条，持有 inFlight 锁，避免同一时刻多次处理
- 建议在 saveQueue 外围做简单互斥或序列化写入，避免并发写覆盖

三、调度器与生命周期

- 单实例：通过命令侧 getScheduler(plugin) 创建与复用
- 不自动启动：用户显式执行 “Scheduler: Start/Stop”
- onload：仅注册命令与监听，不启动 scheduler
- onunload：若存在实例且 running，必须 stop，确保无残留 interval

四、异常与恢复

- 本地临时文件缺失但缓存仍在：走缓存 → 成功上传
- 本地临时文件与缓存都缺失：失败占位，保留队列，支持后续手动/调度重试
- S3 配置问题：全失败；修正配置后重试即可恢复
- 多次启停插件/调度器：不应出现“幽灵定时器”；Status 可观测 running/inFlight/interval

五、日志与可观测性

- 在粘贴、入队、处理、上传、替换、清理各阶段增加结构化日志（含 id、path、队列长度）
- Notice 面向用户关键节点（成功/失败）；控制台用于详细排障
- Status 命令输出调度器状态 + 当前队列长度

六、测试建议（与 TESTING_STRESS.md 配合）

- 并发验证：调度器运行时反复触发“Process Next Item”，确认不重复消费
- 启停回归：禁用/启用插件多轮，观察运行状态与无残留
- 路径健壮性：人为追加 ? 查询串；删除本地文件后检查缓存兜底

七、后续增强

- saveQueue 写入互斥：引入轻量级“写锁”或顺序化写队列
- 指数退避：连续失败时延迟处理下一次尝试（与 Scheduler 配合）
- 指标上报：成功率、失败原因分布、平均等待时长
